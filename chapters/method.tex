% !TeX root = ../Thesis.tex

\chapter{An Approach to Agile Maneuvering}
\label{chap:approach-to-agile-maneuvering}

\section{Concept}\label{sec:concept}
\textcolor{red}{
\begin{itemize}
    \item briefly describe the general concept / framework - see \Cref{fig:overview}
    \begin{itemize}
        \item What do we do here?
        \item how is the planning suppose to work
        \item what modules/step do we need to take to make this work
    \end{itemize} 
    \item brief intro that we now use ROS2 - based on limitations mentioned in \Cref{sec:sw_limitatations} - recent development of ROS2 - promising direction/solution 
    \item just recently stable version of ROS2 - so far made no sense
    \begin{itemize}
        \item what is getting better?
        \item compare with corresponding figure in chapter 2
    \end{itemize}
\end{itemize}}


\begin{figure}
    \centering
    \includesvg[width=\textwidth]{images/03/overview}
	\caption{\textcolor{red}{Proposed Concept - Framework architecture - high level plan - Macht Nathalie heute Nacht/morgen frÃ¼h}}
	\label{fig:overview}
\end{figure}



\begin{figure}[tb]
    \centering
    %\includegraphics{}
    \caption{\textcolor{red}{Architecture using ROS2 --Eigentlich sollte das in Implementierung - dort vllt nodegraph?}}
    \label{fig:my_label1}
\end{figure}

\section{System Dynamic}
\label{sec:system-dynamics}
In the following, we derive the system dynamic of the underactuated HippoCampus \ac{uauv}.

\subsection{Choice of Reference Frames}
We define two reference frames, referred to as \textit{world} and \textit{body} to describe the 6\,DOF motion of the underwater robot.
Figure\,\ref{fig:reference_frames} illustrated the definition of both frames.
\begin{figure}[h!]
	\centering
	\input{images/03/free-body-diagram.pdf_tex}
	\caption{Definition of the world-fixed inertial frame of reference $\mathcal{W}$ and the body-fixed frame $\mathcal{B}$.}
 \label{fig:reference_frames}
\end{figure}

\subsubsection{World-fixed Frame}
For this work, we follow the standard convention in robotics defined as \textit{East-North-Up}\,(ENU).
Its axes are defined through the unit vectors $\prescript{\mathcal{N}}{}{\xb}$, $\prescript{\mathcal{N}}{}{\yb}$, and $\prescript{\mathcal{N}}{}{\zb}$ pointing towards true east, north, and in upward direction, respectively.
Note that this work focuses on applications in confined underwater environments.
Hence, it is often convenient to use a more flexible definition of the inertial reference frame to which we refer to as world frame $\mathcal{W}$.
Consequently, we define this world frame by the unit vectors $\prescript{\mathcal{W}}{}{\xb}$, $\prescript{\mathcal{W}}{}{\yb}$, and $\prescript{\mathcal{W}}{}{\zb}$ and the origin ${O}^{W}$.
This coordinate system is specific to the facility the vehicle is deployed in.
% Using this facility specific reference frame facilitates vehicle deployment within restricted volumes.
% For instance in housed industry tanks where robust measurements of the true north/east directions are not available. 
Hence, a convenient approach is to define the $\prescript{\mathcal{W}}{}{x}$- and $\prescript{\mathcal{W}}{}{y}$- axis along the volume dimensions, e.\,g. along the walls of a rectangular tank while the $\prescript{\mathcal{W}}{}{z}$- axis points in upward direction.
%
%
\subsubsection{Body-fixed Frame}
We define a moving \textit{body} frame $\mathcal{B}$ that is fixed to the vehicle of interest, i.\,e. the underwater robot.
By definition, the body frame's origin ${O}^{B}$ coincidences with the vehicle's center of gravity.%\,(CG).
We follow the common approach to choose body frame axes $\prescript{\mathcal{B}}{}{x}$, $\prescript{\mathcal{B}}{}{y}$, and $\prescript{\mathcal{B}}{}{z}$ such that they align with the vehicles \textit{principal axes of inertia}. 
For the design of the HippoCampus \ac{uauv} we define
\begin{itemize}
    \item $\prescript{\mathcal{B}}{}{x}$: longitudinal axis (directed from back to front, i.\,e. aft to fore),
    \item $\prescript{\mathcal{B}}{}{y}$: transversal axis (directed to the left, i.\.e. port-side),
    \item $\prescript{\mathcal{B}}{}{z}$: normal axis (directed from bottom to top),
\end{itemize}
as depicted in \Cref{fig:reference_frames}.


\subsection{Kinematics}

We write the combined velocity vector \nub as
\begin{equation}
	\nub = 
	\begin{bmatrix}
		\prescript{\mathcal{B}}{}{\vb} \\
		\prescript{\mathcal{B}}{}{\omeb}
	\end{bmatrix}
	,
\end{equation}
with 
\begin{equation}
	\label{eq:velocities-in-body-frame}
	\prescript{\mathcal{B}}{}{\vb} = 
	\begin{bmatrix}
		u & v & w
	\end{bmatrix}^\top
	\text{ and }
	\prescript{\mathcal{B}}{}{\omeb} = 
	\begin{bmatrix}
		p & q & r
	\end{bmatrix}^\top
	,
\end{equation}
where $\prescript{\mathcal{B}}{}{\vb}$ and $\prescript{\mathcal{B}}{}{\omeb}$ are the linear and angular velocity expressed in the body-fixed frame $\mathcal{B}$, respectively.

The pose of the vehicle in the world-fixed frame $\mathcal{W}$ reads

\begin{equation}
	\etab = 
	\begin{bmatrix}
		\prescript{\mathcal{W}}{}{\pbo} \\
		\prescript{\mathcal{W}}{}{\Theb_{\mathcal{W}\mathcal{B}}}
	\end{bmatrix}
	,
\end{equation}
with
\begin{equation}
	\prescript{\mathcal{W}}{}{\pbo} = 
	\begin{bmatrix}
		x & y & z
	\end{bmatrix}^\top
	\text{ and }
	\Theb_{\mathcal{W}\mathcal{B}} =
	\begin{bmatrix}
		\phi & \theta & \psi
	\end{bmatrix}^\top,
\end{equation}
where $\prescript{\mathcal{W}}{}{\pbo}$ is the vehicle's position, i.\,e. the position of body frame origin $O_\mathcal{B}$, with respect to the world frame origin $O_\mathcal{W}$.
Moreover, $\Theb_{\mathcal{W}\mathcal{B}}$ denotes the Euler angle vector describing the rotation between $\mathcal{W}$ and $\mathcal{B}$ following the extrinsic $x$-$y$-$z$ convention.

We write the relation between the linear and angular velocities $\vlinbody$ and $\vangbody$ expressed in the body-fixed frame and the corresponding velocities in the world-fixed frame as
\begin{equation}
	\label[]{eq:velocity-world-body-transformation}
	\begin{bmatrix}
		\vlinworld \\
		\vangworld
	\end{bmatrix}
	=
	\underbrace{
	\begin{bmatrix}
		\Rbodyworld & \bm{0}_{3 \times 3} \\
		\bm{0}_{3 \times 3} & \TbodyWorld
	\end{bmatrix}
	}_{\mbox{\scriptsize $\coloneqq \Jb_\Theta$}}
	\begin{bmatrix}
		\vlinbody \\
		\vangbody
	\end{bmatrix},
\end{equation}
with is the rotation matrix 
\begin{equation}
	\label{eq:rotation-matrix}
	\Rbodyworld = 
	\begin{bmatrix}
		\text{c}\psi\text{c}\theta
		& \text{c}\psi \text{s}\theta \text{s}\phi - \text{s}\psi \text{c}\phi
		& \text{s}\psi \text{s}\phi + \text{c}\psi \text{c}\phi \text{s} \theta \\
		\text{s}\psi \text{c}\theta
		& \text{c}\psi \text{c}\phi + \text{s}\phi \text{s}\theta \text{s}\psi
		& \text{s}\theta \text{s}\psi \text{c}\phi - \text{c}\psi \text{s}\phi \\
		-\text{s}\theta
		& \text{c}\theta \text{s}\phi
		& \text{c}\theta \text{c}\phi
	\end{bmatrix}
\end{equation}
and the transformation matrix
\begin{equation}
	\label{eq:transformation}
	\TbodyWorld = 
	\begin{bmatrix}
		1 & \text{s}\phi \text{t}\theta & \text{c}\phi \text{t}\theta \\
		0 & \text{c}\phi & -\text{s}\phi \\
		0 & \frac{\text{s}\phi}{\text{t}\theta} & \frac{\text{c}\phi}{\text{c}\theta}
	\end{bmatrix},
\end{equation}
where $\text{s}\cdot$, $\text{c}\cdot$ and $\text{t}\cdot$ represent the functions $\sin(\cdot)$, $\cos(\cdot)$ and $\tan(\cdot)$, respectively.

The time derivative of $\Rbodyworld$ is
\begin{equation}
	\label{eq:rotation-matrix-derivative}
	\prescript{\mathcal{W}}{}{\dot{\bm{R}}_{\mathcal{B}}} = \Rbodyworld \Sb(\vangbody)
	,
\end{equation}
with the cross product skew-symmetric matrix
\begin{equation}
	\Sb(\vangbody) = 
	\begin{bmatrix}
		0 & -\vangbodyz & \vangbodyy \\
		\vangbodyz & 0 & -\vangbodyx \\
		-\vangbodyy & \vangbodyx & 0
	\end{bmatrix},
	\quad
	\vangbody = 
	\begin{bmatrix}
		\vangbodyx \\
		\vangbodyy \\ 
		\vangbodyz
	\end{bmatrix}
	.
\end{equation}



\subsection{Equations of Motion}

\begin{itemize}
	\color{red}
	\item Start with the general eq of motion
	\item Apply and justify/explain the simplifications and assumptions to get to the simplified eom in \Cref{eq:equation-of-motion-translational,eq:equation-of-motion-rotational} \todo[inline]{further simplications for trajectory generation. but gazebo simulation uses these equations. how to structure this?}
	\item 
\end{itemize}

In the following, we derive a dynamic model for the HippoCampus \ac{uauv} based on \cite{Fossen11}.
Subsequently, we simplify the model by exploiting the properties of the robot and making reasonable assumptions.

Let
\begin{equation}
	\taub = 
	\begin{bmatrix}
		\prescript{\mathcal{B}}{}{\fb} \\
		\prescript{\mathcal{B}}{}{\mb}
	\end{bmatrix}
\end{equation}
denote the load vector with 
\begin{equation}
	\prescript{\mathcal{B}}{}{\fb} = 
	\begin{bmatrix}
		X & Y & Z
	\end{bmatrix}^\top
	\text{ and }
	\prescript{\mathcal{B}}{}{\mb} = 
	\begin{bmatrix}
		K & M & N
	\end{bmatrix}^\top
\end{equation}
being the forces and moments with respect to the body-fixed frame $\mathcal{B}$.

We write the rigid-body equation of motion as
\begin{equation}
	\label{eq:rigid-body-equation-of-motion}
	\Mrigid \nubp
	+ \Crigid(\nub) \nub
	= \taub
	,
\end{equation}
with
\begin{equation}
	\label{eq:rigid-body-mass-matrix}
	\Mrigid =
	\begin{bmatrix}
		m \Ib_{3 \times 3} & \bm{0} \\
		\bm{0} & \Jb
	\end{bmatrix}
	,
\end{equation}
where $\Mrigid$ is the rigid-body mass matrix, $\Crigid$ is the rigid-body Coriolis and centripetal matrix, and $\Jb$ the vehicle's inertia matrix with respect to its center of gravity.

To account for hydrodynamic and hydrostatic effects, we extend \Cref{eq:rigid-body-equation-of-motion} by the corresponding terms, which yields in accordance with \cite{Fossen11}
\begin{equation}
	\label{eq:6dof-equation-of-motion}
	\Mrigid \nubp + \Crigid(\nub) \nub +
	\underbrace{
		\Madded \nubp +
		\Cadded(\nub) \nub +
		\Dadded(\nub) \nub
	}_\text{hydrodynamic loads}
	+ 
	\underbrace{
		\gb(\etab)
	}_\text{\makebox[0pt]{hydrostatic load}}
	= \taub
	,
\end{equation}
where $\Madded$ is the added mass matrix, $\Cadded$ the added Coriolis matrix, and $\Dadded$ the added damping matrix.
The hydrostatic load, denoted by $\gb(\etab)$, represents the forces acting on the body due to gravity and buoyancy and moments induced by them.

We make the following assumptions with respect to HippoCampus \ac{uauv} to simplify \Cref{eq:6dof-equation-of-motion}:
\begin{itemize}
	\item Symmetry with respect to $xz$, $yz$ and $xy$ planes.
	\item The center of gravity lies in the origin $\bodyframeorigin$ of the body-fixed frame $\mathcal{B}$.
	\item The difference in the magnitudes of buoyancy force and gravitational force is zero, i.e. the vehicle is neutrally buoyant. Therefore, the restoring force is assumed to be zero.
	\item The center of buoyancy and the center of gravity coincide. The resulting restoring moment will be zero.
	\item The vehicle's velocity is relatively small.
	\item The motion of the vehicle is uncoupled.
	\item The principal axes of inertia coincide with the body-fixed frame axes.
\end{itemize}

Using the body symmetry, the added mass matrix becomes \todo{Fossen 7.5.2 p.172}
\begin{equation}
	\Madded =
	\text{diag}\left(X_{\up}, Y_{\vp}, Z_{\wpo}, K_{\pp}, M_{\qp}, N_{\rp}\right)
\end{equation}
and since the axes of inertia coincide with the body-fixed frame, the rigid-body inertia matrix $\Jb$ becomes diagonal as well, i.e.
\begin{equation}
	\Jb = \text{diag}(J_x, J_y, J_z)
	.
\end{equation}
For uncoupled motions \cite{Fossen11} suggests assuming diagonal shape for $\Dadded$ as well. For high speeds, the damping is non-linear. But the speed of the HippoCampus \ac{uauv} is assumed to be small enough, that the linear terms are dominant. Therefore, the damping is approximated as linear function in terms of velocity.
\todo{find a reference for assuming linear terms only. see hastedt}
Hence, the added damping reads
\begin{equation}
	\Dadded(\nub) = -\text{diag}(X_\text{u}, Y_\text{v}, Z_\text{w}, K_\text{p}, M_\text{q}, N_\text{r})
    .
\end{equation}

Since the vehicle is neutrally buoyant and the center of buoyancy and gravity are identical, the hydrostatic forces and moments vanish. Based on these simplifications we rewrite \Cref{eq:6dof-equation-of-motion}. With $\Madded = \text{diag}\left(\Mvadded, \Jadded\right)$ and $\Dadded = \text{diag}(\Dvadded, \Domegaadded)$, we introduce the following auxiliary variables
\begin{equation}
	\Mbs = \left(m\Ib + \Mvadded\right),\text{ and }
	\Jbs = \left(\Jb + \Jadded\right)
\end{equation}
and write \Cref{eq:6dof-equation-of-motion} separated by the translational and rotational dynamics as
\begin{equation}
	\label{eq:equation-of-motion-translational}
	\Mbs \vlinbodydot =
	\vlinbody \times \Mbs \vangbody
	-\Dvadded \vlinbody
	+ \prescript{\mathcal{B}}{}{\fb}
\end{equation}\todo{Muss es nicht nur die obere Haelfte von $\gb$ sein? Muesste $\Mbs$ nicht vor $\vlinbody$ stehen?}
and
\begin{equation}
	\label{eq:equation-of-motion-rotational}
	\Jbs \vangbodydot =
	\vlinbody \times \Mbs \vangbody
	- \vangbody \times \Jbs \vangbody
	- \Domegaadded \vangbody
	+ \prescript{\mathcal{B}}{}{\mb}
	.
\end{equation}

\subsection{Thruster Model}
\label{sec:thruster-model}
The HippoCampus \ac{uauv} has four thrusters mounted in parallel to its forward axis depicted in \Cref{fig:free-body-diagram}.
\begin{figure}[h!]
	\centering
	\input{images/03/free-body-diagram.pdf_tex}
	\caption{Free body diagram of the HippoCampus \mu AUV with buoyancy force $\bm{f}_\textrm{B}$, gravitational force $\bm{f}_\textrm{G}$, thruster forces $\bm{f}_\textrm{1:4}$, and thruster torques $\bm{m}_{1:4}$.}
	\label{fig:free-body-diagram}
\end{figure}
The thruster configuration enables the vehicle to apply forces and moments.
Each thruster applies a force $\fb_{i}$ in the direction of $\exbody$ and induces a moment $\mb_{i}$ around $\bodyframeorigin$.
Furthermore, due to the thruster's rotational movement, it generates a moment around the forward axis. A physically based modelling approach is presented in \cite{Newman77} and following it, we can express the thruster force as
\begin{equation}
	\label{eq:thrust-function-newman}
	f_i = \kappa_{\text{F},i}\rho d^4 n_i^2
	,
\end{equation}
where $n$ are the rotations per second, $d$ is the propeller's diameter, and $\kappa_{\text{F},i}$ is the thruster's force coefficient. In general, $\kappa_{\text{F},i}$ depends on the relative velocity of the fluid surrounding the thruster.

Another relation for the thruster forces is presented in \cite{Hastedt19}, according to which $f_i$ can be modelled quite accurately by
\begin{equation}
	\label{eq:thrust-function-hastedt}
	f_i = \ForceQuadCoeffi \inputesci^2
	+ \ForceLinCoeffi \left\lvert \inputesci \right\rvert
	,
\end{equation}
where $\ForceQuadCoeffi$ and $\ForceLinCoeffi$ denote constant thrust coefficients, and $\inputesci$ is the control input of the \ac{esc} controlling the thruster.
Since the \acp{esc} of the HippoCampus \ac{uauv} do not apply feedback control, we cannot assume the actual velocity for a given $\inputesci$ being constant.
Furthermore, the vehicle has no ability to measure the rotational velocity of the thrusters during operation.
Hence, we choose \Cref{eq:thrust-function-hastedt} over \Cref{eq:thrust-function-newman} for modelling the forces of the thrusters.

This implies three simplifications.
First, we neglect the relative velocity between fluid and thruster.
Second, we neglect the deadzone of the motors.
And last, we do not account for asymmetries in the thrust function regarding the direction of rotation of the thrusters.
The deadzone is a range of $\inputesci$, for which the motors do not start spinning.
As a consequence, forces and moments induced by the thrusters cannot be arbitrarily small.
Neglecting the deadzone seems appropriate, as we can assume a sufficiently high forward thrust during agile maneuvering that keeps the thrusters operating outside their deadzone.

Regarding the thruster dynamics, we assume the forces and moments being reached instantaneously. Considering the much slower vehicle dynamics, this seems justified.

In accordance to \Cref{eq:thrust-function-hastedt}, the moment $m_i$ applied by a thruster reads
\begin{equation}
	\label{eq:moment-function}
	m_i = \MomentQuadCoeffi \inputesci^2
	+ \MomentLinCoeffi \left\lvert \inputesci \right\rvert
	,
\end{equation}
where $\MomentQuadCoeffi$ and $\MomentLinCoeffi$ denote the thruster's moment coefficients.

For each thruster at position $\dbo_{i}$, we can express the load vector $\taub_{i}$ as
\begin{equation}
	\label{eq:load-per-thruster-short}
	\taub_{i} = 
	\begin{bmatrix}
		\fb_i \\
		\dbo_i \times \fb_i + \mb_i
	\end{bmatrix}
	,
\end{equation}
and by substituting with \Cref{eq:thrust-function-hastedt,eq:moment-function} this yields
\begin{equation}
	\taub_{i} = 
	\begin{bmatrix}
		\ForceQuadCoeffi \inputesci^2
		+ \ForceLinCoeffi \left\lvert \inputesci \right\rvert
		\\
		0 \\
		0 \\
		\MomentQuadCoeffi \inputesci^2
		+ \MomentLinCoeffi \left\lvert \inputesci \right\rvert
		\\
		d_{i,z}
		\left(
			\ForceQuadCoeffi \inputesci^2
			+ \ForceLinCoeffi \left\lvert \inputesci \right\rvert
		\right)
		\\
		-d_{i,y}
		\left(
			\ForceQuadCoeffi \inputesci^2
			+ \ForceLinCoeffi \left\lvert \inputesci \right\rvert
		\right)
	\end{bmatrix}
\end{equation}
and as sum over all thrusters
\begin{equation}
	\label{eq:thruster-load-vs-uesc}
	\taub = 
	\sum_{i=1}^{4}
	\begin{bmatrix}
		\ForceQuadCoeffi \inputesci^2
		+ \ForceLinCoeffi \left\lvert \inputesci \right\rvert
		\\
		0 \\
		0 \\
		\MomentQuadCoeffi \inputesci^2
		+ \MomentLinCoeffi \left\lvert \inputesci \right\rvert
		\\
		d_{i,z}
		\left(
			\ForceQuadCoeffi \inputesci^2
			+ \ForceLinCoeffi \left\lvert \inputesci \right\rvert
		\right)
		\\
		-d_{i,y}
		\left(
			\ForceQuadCoeffi \inputesci^2
			+ \ForceLinCoeffi \left\lvert \inputesci \right\rvert
		\right)
	\end{bmatrix}
	.
\end{equation}

By defining the input vector $\inputbody$ as
\begin{equation}
	\label{eq:input-vector}
	\inputbody =
	\begin{bmatrix}
		u_1 &
		0 &
		0 &
		u_2 &
		u_3 &
		u_4 
	\end{bmatrix}^\top
	,
\end{equation}
with
\begin{equation}
	\inputbody = \taub =
	\sum_{i=1}^{4}
	\begin{bmatrix}
		f_i \\
		0 \\
		0 \\
		m_i \\
		d_{i, z} f_i\\
		-d_{i, y} f+i
	\end{bmatrix}
	,
\end{equation}

we rewrite \Cref{eq:equation-of-motion-translational,eq:equation-of-motion-rotational} as
\begin{equation}
	\label{eq:eom-translational-with-input}
	\Mbs \vlinbodydot =
	\vlinbody \times \Mbs \vangbody
	-\Dvadded \vlinbody
	+
	\begin{bmatrix}
		u_1 & 0 & 0
	\end{bmatrix}^\top
\end{equation}
and
\begin{equation}
	\label{eq:eom-rotational-with-input}
	\Jbs \vangbodydot =
	\vlinbody \times \Mbs \vangbody
	- \vangbody \times \Jbs \vangbody
	- \Domegaadded \vangbody
	+
	\begin{bmatrix}
		u_2 & u_3 & u_4
	\end{bmatrix}^\top
	.
\end{equation}

\begin{itemize}
	\color{red}
	\item Rigid body dynamics -> added hydrodynamic terms -> assumptions and simplifications -> yields simplified dynamic model
	\item Thruster model
	\begin{itemize}
		\item assume motor speed is reached instantaneously (fast in comparison to the body dynamics)
		\item assume quadratic thrust curve (Hastedt)
		\item neglect relative velocity
		\item neglect dead band
		\item neglect forward/reverse asymmetry.
	\end{itemize}
\end{itemize}

% \subsection{Differential Flatness (Optional -- Streichen,)}
% \label{sec:differential-flatness}
% {\color{orange}
% 	show diff. flatness and motivate it by highlighting that it is useful for the trajectory-generation section
% }



\section{Trajectory Generation}
\label{sec:trajectory-generation}
\todo{Einfach streichen und irgendwo auf das IROS 2021 mit Christian referenzieren und sagen, dass das for the sake of brevity dort zu finden ist und in detailliert noch mal in meiner diss}
The goal of the generated trajectories is to bring the vehicle from an initial state $\vehiclestate_0$ at time $t=0$ to a desired final state $\vehiclestate_{\text{f}}$ at $t=T$, with the vehicle state being described by 
\begin{equation}
	\vehiclestate = 
	\begin{bmatrix}
		\pbo & \pbp & \pbpp
	\end{bmatrix}^\top
	,
\end{equation}
while being subject to the translational constraints
\begin{equation}
	\label{eq:translational-constraints}
	\ab_j^\top \vehiclestate(t) \leq \bb_j
	\text{ for }
	t \in \left[0,T\right],
	\quad
	j=1,\dots,N_c
	.
\end{equation}
We can interpret these constraints as bounds to the vehicle's position, velocity and acceleration. The positional constraints can be used to encode spatial constraints, such as a confined environment in which the \ac{uauv} is maneuvering. While for \acp{uav} constraints on the acceleration can be used to directly encode limits one the tilt, as presented in \cite{MuellerHehn15}, this is not the case for \acp{uauv}. This is caused by differences in the dynamic models used for \acp{uav} in \cite{MuellerHehn15} and \acp{uauv} as presented in this thesis. A more detailed explanation is given in the course of this section.

In addition to the translational constraints, the trajectory has to respect the dynamic abilities of the vehicle, i.e. the trajectory bringing the vehicle from $\vehiclestate_0$ to $\vehiclestate_\text{f}$ has to be dynamically feasible. This includes respecting the simplified dynamic model we introduce in the following section, as well as bounds to the system input.

For this section, we focus on the generation of the trajectories, before dealing with the feasibility constraints in the next section.

\subsection{Trajectory Dynamics}
\label{sec:trajectory-dynamics}
In this section, we simplify the dynamic model described in \Cref{eq:eom-translational-with-input} and derive equations to calculate the system inputs for a given trajectory. In the following all equations are expressed in the world-fixed frame $\mathcal{W}$ and the corresponding indices are omitted in favor of readability, if unambiguous.

Similar to \cite{MuellerHehn15}, we define the state variable of the trajectory and its derivative as
\begin{equation}
	\label{eq:trajectory-state}
	\sbo = 
	\begin{bmatrix}
		\pbo & \vb & \ab	
	\end{bmatrix}
	\quad
	\text{and}
	\quad
	\sbp =
	\begin{bmatrix}
		\vb &
		\ab &
		\jb
	\end{bmatrix}
\end{equation}
with
\begin{equation}
	\vb = \pbp
	\quad
	\text{and}
	\quad
	\ab = \pbpp
	\quad
	\text{and}
	\quad
	\jb = \pbppp
\end{equation}
being the velocity, acceleration and jerk.

We neglect the cross-coupling term in \Cref{eq:eom-translational-with-input} and can write the translational equation of motion expressed in the world frame $\mathcal{W}$ as
\begin{equation}
	\label{eq:eom-world-without-cross-coupling}
	\Rbodyworld \, \Mbs \, \Rbodyworld^\top \, \pbpp = \Rbodyworld\Dadded\Rbodyworld^\top \pbp + u_1 \exbodyinworld.
\end{equation}
We further assume the \ac{uauv} is mainly moving in surge direction, which seems reasonable when taking the thruster configuration into account. Therefore, we approximate the inertia matrix by
\begin{equation}
	\label{eq:added-mass-trajectory-simplification}
	\Mbs = m\Ib + \text{diag}\left(X_{\dot{u}}, Y_{\dot{v}}, Z_{\dot{w}}\right)
	=
	m\Ib + X_{\dot{u}} \Ib
\end{equation} \todo[inline]{$\approx$ instead of $=$?}
and the damping matrix by
\begin{equation}
	\label{eq:added-damping-trajectory-simplification}
	\Dvadded = -\text{diag}\left(X_\text{u}, Y_\text{v}, Z_\text{w}\right)
	= -X_\text{u} \Ib
	.
\end{equation} \todo[inline]{$\approx$ instead of $=$?}


Using \Cref{eq:added-mass-trajectory-simplification,eq:added-damping-trajectory-simplification}, we rewrite \Cref{eq:eom-world-without-cross-coupling} as
\begin{equation}
	(m+X_{\dot{u}})\pbpp
	=
	-X_u \pbp
	+ u_1\exbodyinworld
\end{equation}

and reordering yields
\begin{equation}
	\label{eq:trajectory-acceleration-eom}
	\pbpp = \frac{\Rbodyworld \exbodyinworld f - X_u \pbp}{m + X_{\dot{u}}},
\end{equation}
where $f=u_1$ denotes the thrust input of the system.

The required thrust, given the acceleration $\pbpp$ and the velocity $\pbp$, can be computed by applying the euclidean norm to \Cref{eq:trajectory-acceleration-eom}
\begin{equation}
	\label{eq:trajectory-thrust}
	f =
	\left\lVert
	\left(m + X_{\dot{u}}\right) \pbpp + X_u \pbp
	\right\rVert.
\end{equation}

We formulate the dynamics in terms of $\pbppp$ to derive an expression for the body rates.
We write the time derivative of \Cref{eq:trajectory-acceleration-eom} as
\begin{equation}
	\label{eq:jerk}
	\pbppp = 
	\frac{1}{m + X_{\dot{u}}}
	\left(
		\Rb \eb_1 \fp 
		+ \Rb \Sb(\omeb)\eb_1 f
		- X_u \pbpp
	\right)
	.
\end{equation}

By squaring \Cref{eq:trajectory-thrust} and applying the first derivative, we get
\begin{equation}
	f\fp = 
	\left(
		\left(m + X_{\dot{u}}\right) \pbpp
		+ X_u \pbp
	\right)^\top
	\left(
		\left(m + X_{\dot{u}}\right) \pbppp
		+ X_u \pbpp
	\right).
\end{equation}
With \Cref*{eq:trajectory-acceleration-eom} this yields
\begin{equation}
	\label{eq:fdot}
	\fp = \left(\Rb \eb_1\right)^\top
	\left(
		\left(m + X_{\dot{u}}\right) \pbppp
		+ X_u \pbpp
	\right)
\end{equation}
for the derivative of the thrust.

We substitute \fp by \Cref{eq:fdot} in \Cref{eq:jerk} and simplify the equation
\begin{equation}
	\pbppp = 
	\frac{1}{m + X_{\up}}
	\left(
		\begin{bmatrix}
			1 & 0 & 0 \\
			0 & 0 & 0 \\
			0 & 0 & 0
		\end{bmatrix}
		\left(
			\left(m + X_{\dot{u}}\right)
			\pbppp
			+ X_u \pbpp
		\right)
		+
		\Rb
		\begin{bmatrix}
			0 \\
			\omega_3 \\
			-\omega_2
		\end{bmatrix}
		f
		- X_u \pbpp
	\right),
\end{equation}
and reordering yields
\begin{equation}
	\label{eq:jerk-vs-bodyrates}
	\begin{bmatrix}
		0 & 0 & 0\\
		0 & 1 & 0\\
		0 & 0 & 1
	\end{bmatrix}
	\pbppp = 
	\Rb
	\begin{bmatrix}
		0 \\
		\omega_3 \\
		- \omega_2
	\end{bmatrix}
	\frac{f}{m + X_{\dot{u}}}
	-
	\begin{bmatrix}
		0 & 0 & 0 \\
		0 & 1 & 0 \\
		0 & 0 & 1
	\end{bmatrix}
	\frac{X_u}{m + X_{\dot{u}}}
	\pbpp
	.
\end{equation}
We can observe, that the angular velocity about the roll axis $\omega_1$ has no influence on the translational dynamics. For the further course of this thesis we assume $\omega_1 = \unit[0]{\frac{rad}{s}}$.

By reordering \Cref{eq:jerk-vs-bodyrates}, we can recover the body rates based on the trajectory state
\begin{equation}
	\label{eq:body-rate-relation}
	\begin{bmatrix}
		0 \\
		\omega_3 \\
		- \omega_2
	\end{bmatrix}
	=
	\frac{1}{f}
	\Rb^\top
	\begin{bmatrix}
		0 & 0 & 0 \\
		0 & 1 & 0 \\
		0 & 0 & 1
	\end{bmatrix}
	\left(
		\left(
			m + X_{\dot{u}}
		\right)
		\pbppp
		+ X_u \pbpp
	\right)
	.
\end{equation}

Since the jerk is related to the system inputs as stated in \Cref{eq:jerk-vs-bodyrates}, we can interpret the jerk as indicator for the required system input. Therefore, we use the jerk to formulate the cost function
\todo[inline]{Problem: The acceleration term means, that we can not set an upper bound for the product of the system inputs as in \cite{MuellerHehn15}. Can I find a better reason why choosing a jerk optimal trajectory is still a good idea?}
\begin{equation}
	\label{eq:cost-function}
	J_\text{\Sigma} = \frac{1}{T} \int_{0}^{T}\left\lVert \pbppp(t)\right\rVert^2 \text{d}t
	,
\end{equation}
and use it to generate trajectories with minimal costs.

% In per axis notation this becomes
% \begin{equation}
% 	\label{eq:trajectory-state-per-axis}
% 	\sbo_{i} =
% 	\begin{bmatrix}
% 		p_{i} &
% 		v_{i} &
% 		a_{i}
% 	\end{bmatrix}
% 	\text{ and }
% 	\sbp_\text{i} =
% 	\begin{bmatrix}
% 		v_{i} &
% 		a_{i} &
% 		j_{i}
% 	\end{bmatrix}
% \end{equation}

\subsection{Kinematic Derivation of the jerk-optimal Trajectory}
\begin{itemize}
	\color{red}
	\item Define the cost function
	\item derive the minimum jerk solution per axis
	\item 
\end{itemize}
In this section, we derive the jerk-minimal trajectory with respect to the cost function defined in \Cref{eq:cost-function}. This is done by decomposing the three-dimensional problem in a per axis notation and finding the optimal solution per axis.

We write \Cref{eq:cost-function} in per axis notation
\begin{equation}
	\label{eq:cost-function-per-axis}
	J_\text{\Sigma} = \sum_{k=1}^{3}J_\text{k}, \text{ where } J_{k} = \frac{1}{T}\int_{0}^{T}\pppp_k(t)^2\text{d}t
	,
\end{equation}
and the state per axis reads
\begin{equation}
	\sbo_{k} = 
	\begin{bmatrix}
		p_k & \pp_k & \ppp_k
	\end{bmatrix}^\top
	.
\end{equation}
We interpret $\pppp_k$ as input and formulate the differential as the function $f_s$ of the state $\sbo_k$ and $\ppp_k$
\begin{equation}
	\sbp_k = 
	f_s(\sbo_k, \pppp_k) = 
	\begin{bmatrix}
		\pp_k & \ppp_k & \pppp_k
	\end{bmatrix}^\top
	.
\end{equation}

We follow \cite{MuellerHehn15} and apply Pontryagin's minimum principle, by defining the costate
\begin{equation}
	\bm{\lambda} =
	\begin{bmatrix}
		\lambda_1 & \lambda_2 & \lambda_3
	\end{bmatrix}^\top
	,
\end{equation}
and the Hamiltonian as
\begin{equation}
	H(\sbo_k,\pppp_k, \bm{\lambda}) = \frac{1}{T} \pppp^2
	+ \bm{\lambda}^\top f_s(\sbo_k, \pppp_k)
	,
\end{equation}
with the costate differential equation
\begin{equation}
	\label{eq:costate-differential-equation}
	\dot{\bm{\lambda}} = -\nabla_s H(\sbo_k^*, \pppp_k^*) = 
	\begin{bmatrix}
		0 & -\lambda_1 & -\lambda_2
	\end{bmatrix}^\top
	,
\end{equation}
where $\sbo_k^*$ and $\pppp_k^*$ denote the optimal state and input, respectively. The solution of \Cref{eq:costate-differential-equation} yields
\begin{equation}
	\bm{\lambda} = \frac{1}{T}
	\begin{bmatrix}
		- 2 \alpha \\
		2 \alpha t + 2 \beta \\
		- \alpha t^2 - 2 \beta t - 2\gamma
	\end{bmatrix},
\end{equation}
where $\alpha$, $\beta$ and $\gamma$ are auxiliary constants.
We can write down the solution for the optimal input trajectory
\begin{equation}
	\label{eq:input-optimal-trajectory}
	\pppp_k^* = \arg\min_{\pppp}H(\sbo_k^*,\pppp_k, \bm{\lambda}) = 
	\frac{1}{2}\alpha t^2 + \beta t + \gamma
\end{equation}
and get the optimal state trajectory by integrating \Cref{eq:input-optimal-trajectory}
\begin{equation}
	\label{eq:optimal-trajectory-per-axis}
	\sbo^* = 
	\begin{bmatrix}
		\frac{\alpha}{120}t^5
		+ \frac{\beta}{24}t^4
		+ \frac{\gamma}{6}t^3
		+ \frac{a_0}{2}t^2
		+ v_0 t
		+ p_0
		\\
		\frac{\alpha}{24} t^4
		+ \frac{\beta}{6} t^3
		+ \frac{\gamma}{2} t^2
		+ a_0 t
		+ v_0
		\\
		\frac{\alpha}{6} t^3
		+ \frac{\beta}{2} t^2
		+ \gamma t
		+ a_0
	\end{bmatrix}
	,
\end{equation}
where $p_0$, $v_0$ and $a_0$ are the initial conditions 
\begin{equation}
	\sbo(0) = 
	\begin{bmatrix}
		p_0 & v_0 & a_0
	\end{bmatrix}^\top
	.
\end{equation}
We can now determine $\alpha$, $\beta$ and $\gamma$ by reordering \Cref{eq:optimal-trajectory-per-axis}
\begin{equation}
	\label{eq:trajectory-coefficients}
	\begin{bmatrix}
		\alpha \\
		\beta \\
		\gamma
	\end{bmatrix}
	=
	\begin{bmatrix}
		720 & -360T & 60T^2 \\
		-360T & 168T^2 & -24T^3 \\
		60T^2 & -24T^3 & 3T^4

	\end{bmatrix}
	\begin{bmatrix}
		\Delta p \\
		\Delta v \\
		\Delta a
	\end{bmatrix}
	,
\end{equation}
with
\begin{equation}
	\label{eq:trajectory-delta-state}
	\begin{bmatrix}
		\Delta p \\
		\Delta v \\
		\Delta a
	\end{bmatrix}
	= 
	\begin{bmatrix}
		p_\text{f} - p_0 - v_0 T - \frac{1}{2}a_0 T^2 \\
		v_\text{f} - v_0 - a_0 T \\
		a_\text{f} - a_0
	\end{bmatrix}
	.
\end{equation}
We see, that the solution of the optimal state trajectory over the time horizon $T$ is constrained by the initial state $\sbo_0$ and the final state $\sbo_\text{f}$. Furthermore, we have seen in \Cref{sec:trajectory-dynamics}, that we can establish a relation between the state trajectory and the system inputs based on the system dynamics in \Cref{eq:trajectory-acceleration-eom}. Because we have not taken any feasibility constraints into account yet, we are able to generate trajectories in a highly efficient manner. For a given set of $T$, $\sbo_0$ and $\sbo_\text{f}$ only a matrix multiplication has to be performed to compute a trajectory. This enables us to generate an amount of trajectories in the magnitude of hundred thousands up to millions per second. A sampling strategy to choose appropriate final states to reach a high level goal is proposed in the following section.

\subsection{Sampling Strategy}
\label{sec:sampling-strategy}
We consider the proposed high level goal of catching or moving through a ring in a spatially confined environment. The time dependent state of the ring is assumed to be known exactly at all times. In general, this is not strictly necessary, and the vehicle could have sensors to measure and estimate the current state of the ring and predict future states based on these observations, but this lies outside the scope of this thesis.


\begin{itemize}
	\color{red}
	\item how to choose the final state to reach the high level goal, i.e. catching the ring as proposed scenario.
	\begin{itemize}
		\item vehicle tip position inside the ring
		\item different final attitudes possible (sampling on a section of a sphere around final tip position)
		\item calculate actual vehicle's position based on that
	\end{itemize}
	\item higher variety of final states increases chance to generate a feasible solution -> refer to following section
	\item introduce additional rotated inertial system to specify axis components or let them unspecified
	\item stress out the difference to MuellerHehn15, due to velocity dependency.
\end{itemize}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{generation_example.png}
	\caption{Generated trajectories for different final states and time horizons.}
\end{figure}
\section{Feasibility of Trajectories}
\label{sec:feasibility}
In the previous section, the trajectory generation approach was presented and the relation between the state trajectory and the system inputs has been established.
Still, we have to ensure the trajectory is actually feasible regarding the translational constraints in \Cref{eq:translational-constraints}, as the constraints are generally neglected during the generation stage.
The same applies to the input feasibility.
Since these constraints are not inherent to the generation stage, they can be considered as feasibility tests, classifying the given trajectory as feasible or not. 

\subsection{Input Feasibility}
\label{sec:input-feasibility}

We can split the problem of input feasibility into two subproblems, thrust feasibility and body rate feasibility. The thrust feasibility check ensures that the vehicle does not exceed its thrust capabilities denoted by $\fmin$ for the minimum and $\fmax$ for the maximum thrust it can generate.
We formulate the thrust constraints as
\begin{equation}
	\label{eq:thrust-limits}
	\unit[0]{N} \leq f_\text{min} \leq f \leq f_\text{max}
	.
\end{equation}
The body rate feasibility check declares a given state trajectory feasible if
\begin{equation}
	\label{eq:body-rates-limit}
	\left\lVert\omeb\right\rVert
	\leq
	\omega_\text{max}
\end{equation}
is guaranteed to be valid over the whole trajectory.

Both checks are applied on the trajectory per axis with sufficient but not necessary criterions for both feasibility and infeasibility. As a consequence there might be feasible (as well as infeasible) trajectories that might be classified as indeterminable. The checks are applied recursively on subsections of the whole interval $\left[0,T\right]$ in case they can not classify the section as provably feasible or unfeasible.

\subsubsection{Thrust Input Feasibility}
\begin{itemize}
	\color{red}
	\item cubic instead of quadratic function is to be solved
	\item stress out, that feasibility criterium is quite coarse -> feasible solution might be classified as indeterminable
	\item following equations are per axis. Indies are omitted if unambiguous.
\end{itemize}
We consider the interval 
\begin{equation}
	\mathcal{T} = \left[\tau_1,\tau_2\right] \subseteq \left[0,T\right]
	,
\end{equation}
for which the thrust feasibility criterion in \Cref{eq:thrust-limits} is fulfilled if and only if
\begin{align}
	\label{eq:thrust-feasibility-equivilency-max}
	\max_{t \in \mathcal{T}} f(t)^2
	&\leq
	f_\text{max}^2 \\
	\label{eq:thrust-feasibility-equivilency-min}
	\min_{t \in \mathcal{T}} f(t)^2
	&\geq
	f_\text{min}^2
	.
\end{align}

By squaring \Cref{eq:trajectory-thrust}, we can write the squared thrust in per-axis notation
\begin{equation}
	\label{eq:thrust-squared-per-axis}
	f^2 = 
	\left\lVert
	\left(m + X_{\dot{u}}\right) \pbpp + X_u \pbp
	\right\rVert^2
	= 
	\sum_{k=1}^{3}
	\left(\left(m + X_{\dot{u}}\right)\ppp_k + X_u \pp_k \right)^2
\end{equation}
and bound the thrust conservatively by summation over the per axis extrema
\begin{align}
	\label{eq:fmax-per-axis}
	\max_{t \in \mathcal{T}} f(t)^2
	&\leq
	\sum_{k=1}^{3}
	\max_{t \in \mathcal{T}}
	\left(
		\left(m + X_{\dot{u}}\right)
		\ppp_k
		+ X_u \pp_k
	\right)^2 \\
	\label{eq:fmin-per-axis}
	\min_{t \in \mathcal{T}} f(t)^2
	&\geq
	\sum_{k=1}^{3}
	\min_{t \in \mathcal{T}}
	\left(
		\left(m + X_{\dot{u}}\right)
		\ppp_k
		+ X_u \pp_k
	\right)^2
	.
\end{align}

We denote the maximum and minimum of the per axis thrust as \fmaxaxis and \fminaxis, respectively \todo{Hier ist im Unterschied zu Mueller eine kubische Funktion fuer die Nullstellen zu loesen} 
and write the extrema in \Cref{eq:fmax-per-axis,eq:fmin-per-axis} as
\begin{align}
	\max_{t \in \mathcal{T}}
	\left(
		\left(m + X_{\dot{u}}\right)
		\ppp_k
		+ X_u \pp_k
	\right)^2
	&= 
	\max\left\{\fmaxaxis^2, \fminaxis^2\right\} \\
	\min_{t \in \mathcal{T}}
	\left(
		\left(m + X_{\dot{u}}\right)
		\ppp_k
		+ X_u \pp_k
	\right)^2
	&=
	\begin{cases}
		\min\left\{\fmaxaxis^2, \fminaxis^2\right\}
		& \text{if } \fmaxaxis\cdot\fminaxis > 0 \\
		0
		& \text{otherwise}
	\end{cases}
\end{align}

A sufficient criterion, rendering the trajectory infeasible, is
\begin{equation}
	\label{eq:sufficient-infeasible-thrust}
	\max\left\{\fmaxaxis^2, \fminaxis^2\right\}
	> \fmaxsquare
	,
\end{equation}
whereas a sufficient criterion for feasibility with respect to the thrust input is if both
\begin{align}
	\label{eq:sufficient-feasible-thrust-max}
	\sum_{k=1}^{3}
	\max_{t \in \mathcal{T}}
	\left\{\fmaxaxis^2, \fminaxis^2\right\}
	& \leq
	\fmaxsquare \\
	\label{eq:sufficient-feasible-thrust-min}
	\sum_{k=1}^{3}
	\min_{t \in \mathcal{T}}
	\left\{\fmaxaxis^2, \fminaxis^2\right\}
	& \geq
	\fminsquare
\end{align}
hold. Note that it might be the case, that neither \Cref{eq:sufficient-infeasible-thrust} nor \Cref{eq:sufficient-feasible-thrust-max,eq:sufficient-feasible-thrust-min} hold. This does not necessarily mean, that the section has to be infeasible. Even though, the highest order term is $\pp_k$ of fourth order due to velocity dependent damping opposed to the \ac{uav} application in \cite{MuellerHehn15}, where it is of order three, we can still consider the per axis criteria as computationally efficient. Finding the extrema of a fourth order polynomial comes down to finding the roots of a third order polynomial, for which a closed form solution exists. Additionally, to find the extrema for the interval $\mathcal{T}$ it is sufficient to solve it once for the whole duration of the trajectory. Subsequently, we check for each interval $\mathcal{T}$, if the candidate for a local extremum lies within $\mathcal{T}$ and find the global extrema for $\mathcal{T}$ by comparing the thrusts of the respective candidate with the thrust values on the boundaries of $\mathcal{T}$. We can conclude, that in the best case, i.e. no local extremum candidate lies within $\mathcal{T}$, two function evaluations of a quartic polynomial are required. Whereas, for the worst case, i.e. all local extremum candidates lie within $\mathcal{T}$, five evaluations are required.

To obtain the thrust function in terms of the state trajectory parameters $\alpha$, $\beta$ and $\gamma$, we plug \Cref{eq:optimal-trajectory-per-axis} into \Cref{eq:trajectory-thrust}, which yields
\begin{equation}
	\begin{aligned}
		f ={}
		&\frac{X_u \alpha}{24} t^4
		+ \frac{X_u \beta + \left(m+X_{\dot{u}}\right)}{6} t^3
		+ \frac{X_u \gamma + \left(m + X_{\dot{u}}\right)}{2} t^2 \\
		& + \left(
			X_u a_0 + \left(m + X_{\dot{u}}\right) \gamma
		\right) t
		+ X_u v_0
		+ \left(m + X_{\dot{u}}\right) a_0
\end{aligned}
\end{equation}
per axis.

\begin{algorithm}
    \caption{CheckThrustFeasibility}
    \label{alg:thrust-feasibility}
	\begin{algorithmic}[1]
		\Function{CheckThrustFeasibility}{$\fmin$, $\fmax$, $\tau_1$, $\tau_2$}
		\If{$\tau_2 - \tau_1 < \tau_{\min}$}
		\Comment{Termination criterion to limit recursion depth}
			\State \textbf{return} indeterminable
		\EndIf
		% \LeftComment check the boundaries of the interval explicitly
		% \State $f_1 \gets$ \Call{Max}{\Call{Thrust}{$\tau_1$}, \Call{Thrust}{$\tau_2$}}
		% \State $f_2 \gets$ \Call{Min}{\Call{Thrust}{$\tau_1$}, \Call{Thrust}{$\tau_2$}}
		% \If{$f_1 > \fmax$}
		% 	\State \textbf{return} infeasible
		% \ElsIf{$f_2 < \fmin$}
		% 	\State \textbf{return} infeasible
		% \EndIf
		\State $\Sigma_{\min}^2 \gets 0$
		\Comment{Sum of $\min(f^2)$ over all axes}
		\State $\Sigma_{\max}^2 \gets 0$
		\Comment{Sum of $\max(f^2)$ over all axes}
		\For{all axes}
			\State $f_1, f_2 \gets \Call{MinMaxThrustOfAxis}{\tau_1, \tau_2}$
			\If{\Call{Max}{$f_1^2,f_2^2$} $> \fmax$} \Comment{a single axis exceeds $\fmax$}
				\State \textbf{return} infeasible
			\EndIf
			\If{$f_1 \cdot f_2 < 0$}
				\State $\Sigma_{\min}^2 \gets \Sigma_{\min}^2$
			\Else
				\State $\Sigma_{\min}^2 \gets \Sigma_{\min}^2 + \Call{Min}{f_1^2, f_2^2}$
			\EndIf
			\State $\Sigma_{\max}^2 \gets \Sigma_{\max}^2 + \Call{Max}{f_1^2, f_2^2}$
		\EndFor
		\If{$\Sigma_{\max}^2 < \fminsquare$}
		\Comment{Apply the infeasibility criterion}
			\State \textbf{return} infeasible
		\ElsIf{$\Sigma_{\min}^2 > \fmaxsquare$}
			\State \textbf{return} infeasible
		\EndIf
		\If{$\Sigma_{\max}^2 \leq \fmaxsquare$ and $\Sigma_{\min}^2 \geq \fminsquare$}
		\Comment{Apply the feasibility criterion}
			\State \textbf{return} feasible
		\Else \Comment{Test feasibility recursively on subintervals}
			\State $\tau_{\text{m}} \gets (\tau_1 + \tau_2) / 2$
			\If {\Call{CheckThrustFeasibility}{$\fmin,\fmax,\tau_1,\tau_{\text{m}}$} $=$ feasible}
				\State \textbf{return} \Call{CheckThrustFeasibility}{$\fmin,\fmax,\tau_{\text{m}},\tau_2$}
			\Else
				\State \textbf{return} infeasible
			\EndIf
		\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\subsubsection{Body Rates Input Feasibility}
\begin{itemize}
	\color{red}
	\item Insert dynamics into definition of jerk
\end{itemize}
We can formulate an upper bound on the body rates by applying the vector induced euclidean norm $\left\lVert\Rb\right\rVert \leq 1$ on \Cref{eq:body-rate-relation}
\begin{equation}
	\label{eq:body-rates-bound}
	\omega_3^2 + \omega_2^2 \leq
	\frac{1}{f^2}
	\left\lVert
		\left(
			m + X_{\dot{u}}
		\right) \pbppp + X_u \pbpp
	\right\rVert^2
	.
\end{equation}
A conservative upper bound of \Cref{eq:body-rates-bound} in per axis notation denoted as $\bar{\omega}^2$ can be written with \Cref{eq:thrust-squared-per-axis} as
\begin{equation}
	\omega_2^2 + \omega_3^2
	\leq
	\bar{\omega}^2
	=
	\frac{
		\sum_{k=1}^{3}
		\max_{t \in \mathcal{T}}
		\left(
			\left(
				m + X_{\dot{u}}
			\right)\dddot{p}_k + X_u \ddot{p}
		\right)^2
	}{
		\sum_{k=1}^{3}
		\min_{t \in \mathcal{T}}
		\left(
			\left(m + X_{\dot{u}}\right)\ppp_k
			+ X_u \pp_k
		\right)^2
	}
	,
\end{equation}

and simplified with \Cref{eq:sufficient-feasible-thrust-min} and defining $\xi_k = \left(m + X_{\dot{u}}\right)\dddot{p}_k + X_u \ddot{p}$ so it reads
\begin{equation}
	\bar{\omega}^2 =
	\frac{
		\sum_{k=1}^{3}
		\max_{t \in \mathcal{T}}
		\xi_k^2
	}{
		\sum_{k=1}^{3}
		\min_{t \in \mathcal{T}}
		\left\{\fmaxaxis^2, \fminaxis^2\right\}
	}
	.
\end{equation}
The minimum and maximum of $\xi_k$ is denoted as \ximaxaxis and \ximinaxis, respectively. With
\begin{equation}
	\max_{t \in \mathcal{T}}
	\left(
		\left(
			m + X_{\dot{u}}
		\right)
		\dddot{p}_k + X_u \ddot{p}
	\right)^2 =
	\max_{t \in \mathcal{T}}
	\left\{
		\ximaxaxis^2, \ximinaxis^2
	\right\}
	,
\end{equation}
we formulate the feasibility criterion with respect to the body rates
\begin{equation}
	\label{eq:body-rates-criterion-per-axis}
	\bar{\omega}^2
	=
	\frac{
		\sum_{k=1}^{3}
		\max_{t \in \mathcal{T}}
		\left\{
			\ximaxaxis^2, \ximinaxis^2
		\right\}
	}{
		\sum_{k=1}^{3}
		\min_{t \in \mathcal{T}}
		\left\{\fmaxaxis^2, \fminaxis^2\right\}
	}
	\leq
	\omegamaxsquare
	.
\end{equation}
This body rate feasibility criterion is analogous to the upper bound criterion for the thrust feasibility in \Cref{eq:sufficient-feasible-thrust-max}. If \Cref{eq:body-rates-criterion-per-axis} does not hold, the tested interval $\mathcal{T}$ is split in half and the feasibility criterion is applied recursively on both subintervals, subsequently.


\subsection{Translational Constraints Feasibility}
At this stage we can check if a trajectory meets the requirements for being classified as input feasible as presented in \Cref{sec:input-feasibility}. Still there is no guarantee, the trajectory will not violate the translational constraints formulated in \Cref{eq:translational-constraints}.

\subsubsection{Position Feasibility}
\label{sec:position-feasibility}
We can formulate position constraints as planes. We define the allowable side of the plane by a normal vector $\nb_{\text{p}}$. We call this kind of positional constraints wall constraints. These wall constraints can be used to encode the constraints due to local conditions, such as the water surface or the walls of a confined environment, the vehicle is not allowed or able to cross. Feasibility has to be tested for critical points only. The critical points are those meeting the sufficient criterion for being at a minimal distance to the plane encoding the wall constraint. We find the critical points by finding the roots of $\pp_{\text{n}}(t) = \nb_{\text{p}}^\top \, \pbp(t)$.
\begin{equation}
	\mathcal{C}_{\text{crit}} =
	\left\{
		t \in \left[ 0, T \right]
		\,\mid\, \pp_{\text{n}}(t) = 0
	\right\}
	\cup
	\left\{0,T\right\}
\end{equation}

The trajectory is feasible with respect to the position constraints if and only if
\begin{equation}
	\label{eq:position-feasibility-criterion}
	\nb_\text{p}^\top
	\left(
		\pbo(t) - \pbo_{\text{p}}
	\right)
	> 0
	\,\forall\, t \in \mathcal{C}_{\text{crit}}
	,
\end{equation}
with $\pbo_{\text{W}}$ denoting an arbitrary point on the plane defining the wall constraint. Geometrically interpreted, we can regard $\pp_{\text{n}}$ as the velocity projected onto the normal direction of the plane given by $\nb_{\text{W}}$.

The position is a quintic polynomial, as we can see in \Cref{eq:optimal-trajectory-per-axis}. Thus, computing $\mathcal{C}_{\text{crit}}$ is done by solving the roots of the fourth-order polynomial $\pp_{\text{n}}$. The feasibility check is carried out by evaluating the left-hand side of \Cref{eq:position-feasibility-criterion} at least twice and most six times per axis. This is similar to the input feasibility checks presented in \Cref{sec:input-feasibility} with the difference that no recursion is needed, though.

\subsubsection{Velocity Feasibility}
\todo{optional}

\section{Obstacle/Collision Avoidance}\label{sec:collision-avoidance}

\begin{itemize}
	\color{red}
	\item Make clear, that obstacle avoidance is not built into the trajectory generation itself. 
	\item can be seen as subsequent feasibility check. 
\end{itemize}

\todo[inline]{Reference \cite{Bucki19}}
As for the translational constraints and the input feasibility, collision avoidance is not inherent to the generation of trajectories, but is applied as a test afterwards. Trajectories failing the test are discarded.
Obstacle avoidance can be added to the trajectory planning straightforwardly by extending the position feasibility test in \Cref{sec:position-feasibility}.
Instead of checking for a collision with a single predefined plane, the position check is performed recursively on subintervals of $\left[0, T\right]$.
For each recursion, a plane separating the section of the trajectory from the convex obstacle $\mathcal{O}$ is defined.
The position feasibility check is performed and if the whole section lies on the allowable side of separating plane, i.e. in the direction away from the object, the section is declared feasible.
Otherwise, the check is performed recursively on the subinterval including the intersection with the separating plane.
The interested reader may refer to \cite{Bucki19} for an exhaustive analysis of such a collision avoidance algorithm in the domain of aerial vehicles.
The pseudocode describing an algorithm performing the collision feasibility test can be seen in \Cref{alg:collision-detection}.
\begin{algorithm}
    \caption{Collision Detection based on \cite{Bucki19}}
    \label{alg:collision-detection}
	\begin{algorithmic}[1]
		\Require $\pbo(0),\pbo(T) \notin \mathcal{O}$
		\Function{CollisionFeasibility}($\tau_{\min}$)
			\If{not $\pbo(0),\pbo(T) \notin \mathcal{O}$}
				\State \textbf{return} infeasible
			\EndIf
			\State \textbf{return}
			\Call{CollisionCheck}{$0, T$}
		\EndFunction
		\Function{CollisionCheck}{$\tau_1, \tau_2$}
		\State $\tau_{\text{mid}} \gets (\tau_1 + \tau_2) / 2$
		\If{$\pbo(\tau_{\text{mid}}) \in \mathcal{O}$}
			\State \textbf{return} infeasible
		\ElsIf{$\tau_2 - \tau_1 < \tau_{\min}$}
			\State \textbf{return} indeterminable
		\EndIf
		\State $\pbo_{\text{p}}, \nb_{\text{p}} \gets$
		\Call{GetSeparatingPlane}{$\pbo(\tau_{\text{mid}}),\mathcal{O}$}
		\State $\mathcal{C}_{\text{crit}} \gets
		\left\{
			t \in \left[ \tau_{\text{mid}}, \tau_2 \right]
			\,\mid\, \pp_{\text{n}}(t) = 0
		\right\}$ in ascending order
		\For{$t_i$ in $\mathcal{C}_{\text{crit}}$, skipping $\tau_{\text{mid}}$}
			\If{$\nb_\text{p}^\top
				\left(
					\pbo(t_i) - \pbo_{\text{p}}
				\right)
				\leq 0$}
				\State result $\gets$ \Call{CollisionCheck}{$t_{i-1},\tau_2$}
				\If{result = feasible}
					\State \textbf{break}
				\Else
					\State \textbf{return} result
					\Comment{either infeasible or indeterminable}
				\EndIf
			\EndIf
		\EndFor
		\State $\mathcal{C}_{\text{crit}} \gets
		\left\{
			t \in \left[ \tau_1, \tau_{\text{mid}}\right]
			\,\mid\, \pp_{\text{n}}(t) = 0
		\right\}$ in descending order
		\For{$t_i$ in $\mathcal{C}_{\text{crit}}$, skipping $\tau_{\text{mid}}$}
			\If{$\nb_\text{p}^\top
			\left(
				\pbo(t_i) - \pbo_{\text{p}}
			\right)
			\leq 0$}
				\State \textbf{return} \Call{CollisionCheck}{$\tau_1, \tau_{\text{mid}}$}
			\EndIf
		\EndFor
		\State \textbf{return} feasible
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The recursion depth of \Cref{alg:collision-detection} is limited by $\tau_{\min}$.
If an examined section of the trajectory bounded by the time interval $\left[\tau_1, \tau_2\right]$ becomes small enough that $\tau_2 - \tau_1 < \tau_{\min}$, the trajectory is declared indeterminable.
Computation time wise, we can expect the choice of $\tau_{\min}$ to have a significant influence for indeterminable trajectories.
This is, because $\tau_{\min}$ limits the recursion depth in case no subinterval has been declared infeasible yet, nor could feasibility be guaranteed for the whole interval $\left[0, T\right]$.
Choosing $\tau_{\min}$ larger reduces the time required in case feasibility could not be decided upon before splitting the interval in smaller sections than $\tau_{\min}$.
On the other hand, choosing $\tau_{\min}$ smaller could result in trajectories being declared as feasible, that would have been discarded as indeterminable otherwise.

Note that we are not restricted to static obstacles by this approach of obstacle avoidance. We define the trajectory of the relative position of the vehicle to the obstacle as
\begin{equation}
	\pbs(t) = \pbo(t) - \pbo_{\mathcal{O}}(t)
	,
\end{equation}
where $\pbo_{\mathcal{O}}(t)$ denotes the obstacle's trajectory. Instead of performing the collision check for $\pbo$, we do it for $\pbs$. In general, $\pbo_{\mathcal{O}}$ and consequently $\pbs$ could be arbitrary functions of time.
But choosing them not to be a polynomial of order at most five, would render the collision avoidance significantly less computational efficient. Hence, we assume the trajectories being of at most order five, and the collision avoidance being performable by solving roots of quartic polynomials.

\begin{tikzpicture}
    \begin{axis}[
            xmin=-2,xmax=1,
            ymin=-3,ymax=3,
            grid=both,
            ]
            \addplot [domain=-0.5:3.5,samples=50]({-1.083 * x^3 + 5.25 * x^2 -6.67*x + 1},{0.167 * x^3 - 0.25 * x^2 + 0.583 *x - 2}); 
    \end{axis}
\end{tikzpicture}

\section{Control}
\label{sec:control}
\begin{itemize}
	\color{red}
	\item one could use the min jerk trajectory approach simply for generation -> feed-back control to keep the vehicle on track
	\item computational efficiency and real-time capability of approach enables trajectory generation to be used for implicit feedback. Regenerate trajectories in each control time step.
	\item body rates will change rather slowly compared to quadrocopters -> instead of using body rates as in MuellerHehn15, use target attitude and attitude control (actually the body rates are derived from a target attitude anyway)
\end{itemize}
While we attended to the generation and planning of trajectories and the question of feasibility regarding vehicle dynamics, translational constraints and collision avoidance in the previous sections, this section is about tracking the obtained trajectories.

The general control architecture implements the inner-outer loop control scheme as depicted in \Cref{fig:inner-outer-loop-feedback-control}.
\begin{figure}
	\centering
	\begin{tikzpicture}

    \scriptsize

    \def\blockheight{1.5cm}
    \def\blockwidth{1.5cm}
    \def\xshiftblocks{0cm}
    \def\yshifttwolines{0.3cm}  % yshift for connecting lines between blocks when two lines above each other are used
    \def\yshiftthreelines{0.4cm}  % yshift for connecting lines between blocks when three lines above each other are used
    \def\yshiftfourlines{0.4cm}
    \def\yshiftbelowvehiclefirst{-0.5cm}
    \def\yshiftbelowvehicleoffset{-0.2cm}
    \def\yshiftaboveblocks{0.5cm}
    \def\xshiftfirstuintomixer{-0.8cm}    

        % Blocks
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center] (generator) at (0,0) {Trajectory\\Generator};
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of generator, xshift=\xshiftblocks] (trackingcontroller) {Trajectory\\Tracking\\Controller};
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of trackingcontroller, xshift=\xshiftblocks] (attitudecontroller) {Attitude\\Controller};
        \node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of attitudecontroller, xshift=\xshiftblocks] (ratecontroller)  {Rate\\Controller};
        \node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth-0.5cm, minimum height=2cm, align=center, right= of ratecontroller, xshift=\xshiftblocks] (mixer)  {Mixer};
        \node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth-0.3cm, minimum height=\blockheight, align=center, right= of mixer, xshift=\xshiftblocks+0.7cm] (vehicle)  {Vehicle};
		
        % trajectory generator - trajectory tracking controller
		\draw[-stealth] (generator.east) -- (trackingcontroller.west) node[midway, above] {$\bm{\sigma}_{\text{des}}$};

        % trajectory tracking controller - attitude controller
        \draw[-stealth] ([yshift=\yshifttwolines]trackingcontroller.east) -- ([yshift=\yshifttwolines]attitudecontroller.west) node[midway, above] {$\bm{f}_{\text{des}}$};
        \draw[-stealth] ([yshift=-\yshifttwolines]trackingcontroller.east) -- ([yshift=-\yshifttwolines]attitudecontroller.west) node[midway, above] {$\bm{\phi}_{\text{des}}$};
        
        % attitude controller - rate controller
        \draw[-stealth] (attitudecontroller.east) -- (ratecontroller.west) node[midway, above] {$\bm{\omega}_{\text{des}}$};

        % rate controller - mixer
		\draw[-stealth] ([yshift=\yshiftthreelines]ratecontroller.east) -- ([yshift=\yshiftthreelines]mixer.west) node[midway, above] {$u_2$};
        \draw[-stealth] ([yshift=0cm]ratecontroller.east) -- ([yshift=0cm]mixer.west) node[midway, above] {$u_3$};
        \draw[-stealth] ([yshift=-\yshiftthreelines]ratecontroller.east) -- ([yshift=-\yshiftthreelines]mixer.west) node[midway, above] {$u_4$};

        % mixer - vehicle
        \draw[-stealth] ([yshift=\yshiftfourlines]mixer.east) -- ([yshift=\yshiftfourlines]vehicle.west) node[midway, above, align=center] {ESC\\commands};
        \draw[-stealth] ([yshift=1/3*\yshiftfourlines]mixer.east) -- ([yshift=1/3*\yshiftfourlines]vehicle.west) node[midway, above] {};
        \draw[-stealth] ([yshift=-1/3*\yshiftfourlines]mixer.east) -- ([yshift=-1/3*\yshiftfourlines]vehicle.west) node[midway, above] {};
        \draw[-stealth] ([yshift=-\yshiftfourlines]mixer.east) -- ([yshift=-\yshiftfourlines]vehicle.west) node[midway, below] {};

        % vehicle - below all other blocks
        \draw[-stealth] ([xshift=-0.2cm]vehicle.south) -- ++(0, \yshiftbelowvehiclefirst) -- ([yshift=\yshiftbelowvehiclefirst]ratecontroller.south) -- (ratecontroller.south) node[midway, right] {$\omeb, \omebp$};
        \draw[-stealth] ([xshift=-0cm]vehicle.south) -- ++(0, \yshiftbelowvehiclefirst+\yshiftbelowvehicleoffset) -- ([yshift=\yshiftbelowvehiclefirst+\yshiftbelowvehicleoffset]attitudecontroller.south) -- (attitudecontroller.south) node[midway, right] {$\qb$};
        \draw[-stealth] ([xshift=0.2cm]vehicle.south) -- ++(0, \yshiftbelowvehiclefirst+2*\yshiftbelowvehicleoffset) -- ([yshift=\yshiftbelowvehiclefirst+2*\yshiftbelowvehicleoffset]trackingcontroller.south) -- (trackingcontroller.south) node[midway, right] {$\pbo,\pbp$};
        \draw[-stealth] ([yshift=\yshiftbelowvehiclefirst+2*\yshiftbelowvehicleoffset]trackingcontroller.south) -- ([yshift=\yshiftbelowvehiclefirst+2*\yshiftbelowvehicleoffset]generator.south) -- (generator.south) node[midway, right] {$\pbo,\pbp,\pbpp$};

        % trajectory tracking controller - mixer (above blocks)
        \draw[-stealth] ([xshift=0.3cm]trackingcontroller.north) -- ++(0, \yshiftaboveblocks) -- ([xshift=\xshiftfirstuintomixer, yshift=\yshiftaboveblocks+0.5*\blockheight]mixer.west) -- ([xshift=\xshiftfirstuintomixer, yshift=2*\yshiftthreelines]mixer.west) -- ([yshift=2*\yshiftthreelines]mixer.west) node[midway, above] {$u_1$};

	\end{tikzpicture}
	\caption{Overview of the control loops.}
	\label{fig:inner-outer-loop-feedback-control}
\end{figure}
The authors in \cite{Maurya09} demonstrated the viability of this approach for marine vehicles. The basic idea is to divide the problem of trajectory into easier-to-solve subproblems. By inner loops, we refer to the low-level dynamic control loops consisting of attitude or body rate controllers. The design and tuning of these inner loops are highly dependent on the vehicle dynamics. The outer control loops, for example, a position, path, or trajectory tracking controller, can be considered as kinematic control loops. They are by design decoupled from vehicle dynamics under the assumption, that the inner control loops are fast enough to reach the target value instantaneously from the perspective of the outer loop. This is equivalent to the assumption in \Cref{sec:thruster-model}, that the thruster dynamics compared to the \ac{uauv} dynamics are sufficiently fast to be negligible. As a result, we have a fast-slow separation from the inner to the outer loop, i.e. the inner loops run with a significantly higher frequency than the outer ones.







\subsection{Body Rate Control}
The body rate controller represents the innermost control loop.

We define the error of the angular velocity and acceleration in the body-fixed frame $\mathcal{B}$
\begin{equation}
	\vangerror = \vangbody - \vangdesiredbody \quad \text{and} \quad
	\aangerror = \aangbody - \aangdesiredbody
	,
\end{equation}
and the control law for controlling $\vangbody$, reading
\begin{align}
	\begin{bmatrix}
		u_2 \\ u_3 \\ u_4
	\end{bmatrix}
	=
	\KpBodyRate \vangerror
	&+ \KiBodyRate \int_{}^{t} \vangerror(\tau)\text{d}\tau
	+ \KdBodyRate \aangerror \\\nonumber
	&+\underbrace{
		\vangdesiredbody \times \Jbs \vangdesiredbody
		+ \Domegaadded \vangdesiredbody
		- \vlinbody \times \Mbs \vangdesiredbody
	}_{\text{feed forward}}
	,
\end{align}
\todo{add p and d term and we have pid with feedfoward. }
where the feed forward terms are based on vehicle dynamics in \Cref{eq:eom-rotational-with-input}. The control law displays a PID-Controller with feed forward term, where $\KpBodyRate$, $\KiBodyRate$ and $\KdBodyRate$ are diagonal matrices denoting the proportional, integral and derivative gain, respectively.

We set $\aangdesiredbody = \unit[0]{rad/s^2}$ and observe that the input for the body rate controller is $\vangdesiredbody$. We will see in \Cref{sec:implicit-feedback-control} the usefulness of this for the implicit feedback control scheme in the context of the trajectory generation system, given the inner-outer loop assumptions hold.

\subsection{Attitude Control}
The attitude controller is the next controller upstream of the body rate controller. Hence, we consider it to be a kinematic controller with a desired body rate $\vangdesiredbody$ as output, instead of the vehicle's system inputs $\inputbody$. We define the desired thrust axis as the controller's input 
\begin{equation}
	\exdesiredbodyinworld =
	\frac{\thrustdesiredworld}{
		\left\lVert\thrustdesiredworld\right\rVert
	}
\end{equation}
and the current thrust axis, that is equivalent to 
\begin{equation}
	\exbodyinworld = \qactual \odot \eb_1
	,
\end{equation}
where $\qactual \odot \eb_1$ denotes the rotation of the vector $\eb_1$ by the quaternion $\qactual$ and $\qactual$ is the current attitude of the vehicle.

It is the task of the controller to compute a desired attitude given by the quaternion $\qdesired$ and compute the required body rates $\vangdesiredbody$, that rotate the vehicle to desired attitude. We define the error of the attitude as
\begin{equation}
	\label{eq:qerror}
	\qerror = \qactual^{-1} \cdot \qdesired
	.
\end{equation}

The alignment of $\exdesiredbodyinworld$ and $\exbodyinworld$ constraints two of the three rotational degrees of freedom of the vehicle, namely pitch and yaw.
The rotation around the roll axis $\exbodyinworld$ can be chosen freely.

The quaternion-based control law
\begin{equation}
	\label{eq:control-law-attitude}
	\vangdesiredbody = 
	\frac{2}{\tau}
	\text{sgn}(q_{\text{e},0})
	\qb_{\text{e},1:3}
\end{equation}
is globally asymptotically stable and fits the architecture of inner-outer loops \cite{Mayhew11,Brescianini13}, which is desirable in the context of agile maneuvering. The parameter $\tau$ can be interpreted as first-order time constant of the attitude controller. In practice, too small or too large values may lead to bad control performance \cite{Brescianini13} and an appropriate value has to be determined by tuning of the controller.

The axis-angle representation of the rotation aligning $\exbodyinworld$ and $\exdesiredbodyinworld$ is given by
\begin{equation}
	\rotationaxisworld = \frac{
		\exbodyinworld \times \exdesiredbodyinworld
	}{
		\left\lVert
			\exbodyinworld \times \exdesiredbodyinworld
		\right\rVert
	}
	\quad \text{and} \quad
	\alpha = \arccos
	\left(
		\exbodyinworld^\top \exdesiredbodyinworld
	\right)
	.
\end{equation}
We construct the error quaternion for pitch and yaw straightforwardly from the angle-axis representation 
\begin{equation}
	\qerrorPY = 
	\begin{cases}
		\begin{bmatrix}
			\cos(\frac{\alpha}{2}) \\
			\sin(\frac{\alpha}{2}) \rotationaxisworld
		\end{bmatrix} &\text{if } \alpha \neq 0 \\
		\begin{bmatrix}
			1 & 0 & 0 & 0
		\end{bmatrix}^\top
		& \text{else.}
	\end{cases}
\end{equation}
Note that the way we construct the rotation axis, it will never cause a rotation around the vehicle's roll axis as $\exdesiredbodyinworld \perp \exbodyinworld \times \exdesiredbodyinworld$ per definition of the cross product. 

The desired attitude aligning $\exdesiredbodyinworld$ and $\exbodyinworld$ reads
\begin{equation}
	\qdesiredPY = \qactual \cdot \qerrorPY
	.
\end{equation}

\textcolor{red}{Recall the coordinate frame $\mathcal{C}$ from \Cref{sec:differential-flatness}}
\begin{equation}
	\eyinterinworld =
	\begin{bmatrix}
		0 & \cos(\rolldesired) & \sin(\rolldesired)
	\end{bmatrix}^\top
	\quad \text{and} \quad
	\ezinterinworld =
	\begin{bmatrix}
		0 & -\cos(\rolldesired) & \sin(\rolldesired)
	\end{bmatrix}
	.
\end{equation}
\todo[line]{write some text here}
From this it follows
\begin{align}
	\eydesiredbodyinworld = 
	\frac{\ezinterinworld \times \exdesiredbodyinworld}{
		\left\lVert
			\ezinterinworld \times \exdesiredbodyinworld
		\right\rVert
	}\quad \text{and}
	\ezdesiredbodyinworld =
	\exdesiredbodyinworld \times \eydesiredbodyinworld.
\end{align}
We can construct $\qdesiredfull$ from the three desired body axes and define
\begin{equation}
	\qmix = \qdesiredPY^{-1} \cdot \qdesiredfull =
	\begin{bmatrix}
		\cos\left(\frac{\anglemix}{2}\right) \\
		\sin\left(\frac{\anglemix}{2}\right) \\
		0 \\
		0
	\end{bmatrix},
\end{equation}
as the rotation between $\qdesiredPY$ and $\qdesiredfull$ with $\anglemix$ being the rotation angle. We can scale $\anglemix$ by $p \in \left[0,1\right]$ to determine the fraction of $\rolldesired$ to consider for the desired attitude
\begin{equation}
	\label{eq:qdesired}
	\qdesired = \qdesiredPY
	\begin{bmatrix}
		\cos\left(p\frac{\anglemix}{2}\right) \\
		\sin\left(p\frac{\anglemix}{2}\right) \\
		0 \\
		0
	\end{bmatrix}
	.
\end{equation}
We plug \Cref{eq:qdesired} in \Cref{eq:qerror} to apply the control law in \Cref{eq:control-law-attitude}.



\subsection{Implicit Feedback Control}
\label{sec:implicit-feedback-control}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.8\textwidth]{trajectory-replanning}
	\caption{Implicit feedback control by regenerating new trajectories and selecting the best in each step.}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}

    \scriptsize

    \def\blockheight{1.5cm}
    \def\blockwidth{1.5cm}
    \def\xshiftblocks{0cm}
    \def\yshifttwolines{0.3cm}  % yshift for connecting lines between blocks when two lines above each other are used
    \def\yshiftthreelines{0.4cm}  % yshift for connecting lines between blocks when three lines above each other are used
    \def\yshiftfourlines{0.4cm}
    \def\yshiftbelowvehiclefirst{-0.5cm}
    \def\yshiftbelowvehicleoffset{-0.2cm}
    \def\yshiftaboveblocks{0.5cm}
    \def\xshiftfirstuintomixer{-0.8cm}    

        % Blocks
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center] (generator) at (0,0) {Trajectory\\Generator};
        \node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of generator, xshift=\xshiftblocks] (ratecontroller)  {Rate\\Controller};
        \node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth-0.3cm, minimum height=2cm, align=center, right= of ratecontroller, xshift=\xshiftblocks] (mixer)  {Mixer};
        \node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of mixer, xshift=\xshiftblocks+0.7cm] (vehicle)  {Vehicle};
		
        % generator controller - rate controller
        \draw[-stealth] (generator.east) -- (ratecontroller.west) node[midway, above] {$\bm{\omega}_{\text{des}}$};

        % rate controller - mixer
		\draw[-stealth] ([yshift=\yshiftthreelines]ratecontroller.east) -- ([yshift=\yshiftthreelines]mixer.west) node[midway, above] {$u_2$};
        \draw[-stealth] ([yshift=0cm]ratecontroller.east) -- ([yshift=0cm]mixer.west) node[midway, above] {$u_3$};
        \draw[-stealth] ([yshift=-\yshiftthreelines]ratecontroller.east) -- ([yshift=-\yshiftthreelines]mixer.west) node[midway, above] {$u_4$};

        % mixer - vehicle
        \draw[-stealth] ([yshift=\yshiftfourlines]mixer.east) -- ([yshift=\yshiftfourlines]vehicle.west) node[midway, above, align=center] {ESC\\commands};
        \draw[-stealth] ([yshift=1/3*\yshiftfourlines]mixer.east) -- ([yshift=1/3*\yshiftfourlines]vehicle.west) node[midway, above] {};
        \draw[-stealth] ([yshift=-1/3*\yshiftfourlines]mixer.east) -- ([yshift=-1/3*\yshiftfourlines]vehicle.west) node[midway, above] {};
        \draw[-stealth] ([yshift=-\yshiftfourlines]mixer.east) -- ([yshift=-\yshiftfourlines]vehicle.west) node[midway, below] {};

        % vehicle - below all other blocks
        \draw[-stealth] ([xshift=-0.2cm]vehicle.south) -- ++(0, \yshiftbelowvehiclefirst) -- ([yshift=\yshiftbelowvehiclefirst]ratecontroller.south) -- (ratecontroller.south) node[midway, right] {$\omeb, \omebp$};
        \draw[-stealth] ([xshift=0.2cm]vehicle.south) -- ++(0, \yshiftbelowvehiclefirst+2*\yshiftbelowvehicleoffset) -- ([yshift=\yshiftbelowvehiclefirst+2*\yshiftbelowvehicleoffset]trackingcontroller.south) -- ([yshift=\yshiftbelowvehiclefirst+2*\yshiftbelowvehicleoffset]generator.south) -- (generator.south) node[midway, right] {$\pbo,\pbp,\pbpp$};

        % u1 -  trajectory generator - mixer (above blocks)
        \draw[-stealth] ([xshift=0.3cm]generator.north) -- ++(0, \yshiftaboveblocks) -- ([xshift=\xshiftfirstuintomixer, yshift=\yshiftaboveblocks+0.5*\blockheight]mixer.west) -- ([xshift=\xshiftfirstuintomixer, yshift=2*\yshiftthreelines]mixer.west) -- ([yshift=2*\yshiftthreelines]mixer.west) node[midway, above] {$u_1$};

	\end{tikzpicture}
	\caption{\textcolor{blue}{Overview of the control loops using implicit feedback. Note that ...}}
	\label{fig:control_architecture}
\end{figure}





One advantage of the presented trajectory generation approach is, that it is computationally cheap. Hence, we can use the trajectory generation for implicit feedback control, due to the real-time capability of the trajectory planning. We are able to resample thousands of trajectories per control update step and choose the one best suited to accomplish a certain high level task.
Subsequently, we need to recover the required thrust vector and commands for the rotational dynamics of the vehicle.

First, we compute the thrust vector $\thrustdesiredworld$ of the current trajectory at $t+\Delta T_\text{s}$, where $\Delta T_{\text{s}}$ is the update interval for the trajectory sampling, by applying the relation in \Cref{eq:trajectory-acceleration-eom} on the current trajectory.
We compute the axis of rotation $\kb$ and the corresponding angle of rotation $\alpha$ required for aligning the current forward axis of the vehicle $\exbodyinworld$ with $\thrustdesiredworld$ by
\begin{equation}
	\label{eq:rotation-to-desired-thrust-vector}
	\rotationaxisworld = \frac{
		\exbodyinworld \times \thrustdesiredworld
	}{
		\left\lVert
			\exbodyinworld \times \thrustdesiredworld
		\right\rVert}
	\quad
	\text{and}
	\quad
	\alpha = \arccos\left(
		\exbodyinworld \cdot
		\frac{\thrustdesiredworld}{\left\lVert\thrustdesiredworld\right\rVert}
	\right)
	.
\end{equation}
In general, it is also possible to rotate $\exbodyinworld$ by $-\alpha$ around $-\kb$ to align it with $\thrustdesiredworld$. Hence, we invert the signs of $\alpha$ and $\kb$ in case $\lvert\alpha\rvert > \pi$, so we always get the shortest rotation. \todo{not necessary, since we multiply $\alpha$ and $\kb$?}

From \Cref{eq:rotation-to-desired-thrust-vector} we compute the body rates required to align $\exbodyinworld$ with $\thrustdesiredworld$ in time $\Delta T_{\text{s}}$ directly
\begin{equation}
	\vangdesiredworld = \frac{\alpha}{\Delta T_{\text{s}}} \rotationaxisworld
\end{equation}

We close the feedback loop for the trajectory tracking implicitly, i.e. we compute $\thrustdesiredworld$ and $\vangdesiredworld$ in each control loop for a newly generated trajectory.
Therefore, disturbances and model inaccuracies can be compensated, because the new initial state of the generated trajectories is the actual state of the \ac{uauv}.

\subsection{Trajectory Tracking Feedback Control}
\begin{itemize}
	\item \cite{Maurya09} suggests inner-outer-loop. slow-fast, dynamic-kinematic. -> i want to go with this.
\end{itemize}
There might be cases, for those it is desirable or even necessary to track a given trajectory for a longer period then $\Delta T_{\text{s}}$ before being given a new trajectory to track.
For example, when all newly generated trajectories become infeasible. According to \cite{MuellerHehn15} this is to be expected, when the duration of the sampled trajectories becomes small.
As a consequence input feasibility checks will fail and render all trajectories infeasible.
But even for sufficiently large durations, the feasibility still depends on the combination of the initial state and the desired final state.
While we can try to choose appropriate final states, to increase the probability of getting feasible trajectories, there is no way we can influence the initial state, as it is the actual state of the \ac{uauv}.
In this case, there is no trajectory available and the implicit feedback control from the previous section can not be applied.

Theoretically, we could simply compute $\thrustdesiredworld$ and $\vangdesiredworld$ over the remainder of the last planned feasible trajectory.
In practice, model inaccuracies and external disturbances will cause the actual trajectory to diverge from the planned desired trajectory over time.
We tackle this issue by extending the architecture by a trajectory tracking feedback controller.

For the trajectory tracking, we will design a control law based on the one proposed in \cite{MellingerKumar11} for a quadrocopter tracking minimum snap trajectories.

Given a desired trajectory $\bm{\sigma}_{\text{des}}(t) = \left[\pbo_{\text{des}}(t), \rolldesired(t)\right]^\top$, we define the position and velocity error as
\begin{equation}
	\eb_{p} = \pbo - \pbo_{\text{des}}
\end{equation}
and
\begin{equation}
	\eb_{v} = \pbp - \pbp_{\text{des}}
	,
\end{equation}
respectively.

Considering the translational dynamics of the \ac{uauv} in \Cref{eq:eom-translational-with-input}, we formulate the control law
\begin{equation}
	\label{eq:translational-control-law-short}
	u_1 = \exbodyinworld^\top \thrustdesiredworld
\end{equation}
with
\begin{equation}
	\thrustdesiredworld =
	-\Kb_p \eb_p
	- \Kb_v \eb_v
	+ \hat{\bm{M}} \pbpp
	+ \hat{\bm{D}} \pbp
	,
\end{equation}
where $\Kb_p$ and $\Kb_v$ denote diagonal gain matrices and $\hat{\bm{M}} \pbpp$ and $\hat{\bm{D}}\pbp$ represent feed forward terms. Note that $u_1$ is scaled by the projection of $\thrustdesiredworld$ onto the current body axis $\exbodyinworld$.

The advantages of this are two-fold. First, the closer $\thrustdesiredworld$ and $\exbodyinworld$ get of becoming perpendicular, the smaller $u_1$ will become. Therefore, more of the available thruster output can be allocated to minimize the attitude error. Second, for $\thrustdesiredworld$ and $\exbodyinworld$ we can see that $u_1$ can become negative. While usually not useful in the typical application of \acp{uav}, where the thrusters' direction of rotation is not reversible, \acp{uauv} can make use of backward directed thrust to minimize the translational errors $\eb_p$ and $\eb_v$. In case this should not be desired, though, we can still set $u_1=0$ if $\exbodyinworld^\top \thrustdesiredworld < 0$. Accordingly, we reformulate \Cref{eq:translational-control-law-short}
\begin{equation}
	u_1 = 
	\begin{cases}
		\exbodyinworld^T \thrustdesiredworld & \text{if } \exbodyinworld^T \thrustdesiredworld > 0 \\
		0 & \text{else.}
	\end{cases}
\end{equation}

The desired roll angle $\rolldesired$ and the desired thrust $\thrustdesiredworld$ are sent to the lower level control loops.




\section{Implementation}
\label{sec:implementation}


\textcolor{blue}{
\begin{itemize}
    \item Vor dem ROS2 gedÃ¶ns hier nochmal auf die genauere umsetzung des Algorithmus eingehen? \textcolor{red}{Oder sollte das in ein extra 'algorithm overview' section? }
    \item \Cref{fig:information-flow} - FÃ¼r den zeitlichen ablauf / die implementierung des gesamten algorithmus
\end{itemize}
}

\begin{figure}
	\centering
	\begin{tikzpicture}
		
		\scriptsize
		
		\def\blockheight{1.5cm}
		\def\blockwidth{1.8cm}
		\def\xshiftblocks{0.4cm}
		\def\yshiftblocks{-0.4cm}
		
		% Blocks
		%\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center] (generator) at (0,0) {Trajectory\\Generator};
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, xshift=\xshiftblocks] (planner) at (0,0) {Planner};
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, below= of planner, yshift=\yshiftblocks] (sampling) {Sampling\\Goal\\States};
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of sampling, xshift=\xshiftblocks] (generation)  {Trajectory\\Generation};
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of generation, xshift=\xshiftblocks] (feasibility)  {Feasibility\\Checks};
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of feasibility,  xshift=\xshiftblocks] (picker)  {Pick\\Trajectory};
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of picker,  xshift=\xshiftblocks] (trackingcontrol)  {Tracking\\Control};
		\node[draw, fill=lightgray, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, below= of trackingcontrol,  yshift=\yshiftblocks] (lowlevelcontrol)  {Low-Level\\Control};
		
		% Planner - Sampling goal state
		\draw[-stealth] (planner.south) -- (sampling.north) node[midway, right] {high-level goal};
		
		% Sampler - Generator
		\draw[-stealth] (sampling.east) -- (generation.west) node[midway, above, align=center] {goal} node[midway, below] {states};
		
		% Generator - feasibility
		\draw[-stealth] (generation.east) -- (feasibility.west) node[midway, above, align=center] {min. jerk} node[midway, below, align=center] {trajec-\\tories};
		
		% feasibility - picker
		\draw[-stealth] (feasibility.east) -- (picker.west) node[midway, above, align=center] {traj.} node[midway, below, align=center] {candi-\\dates};
		
		% picker - control
		\draw[-stealth] (picker.east) -- (trackingcontrol.west) node[midway, above, align=center] {??} node[midway, below, align=center] {??};
		
		% tracking controller - low level
		\draw[-stealth] (trackingcontrol.south) -- (lowlevelcontrol.north) node[midway, left, align=center] {desired\\orientation,\\thrust};
		
				% tracking controller - low level
		\draw[-stealth] (lowlevelcontrol.south) -- ++(0,-1cm) node[midway, left, align=center] {motor\\commands};
		
	\end{tikzpicture}
	\caption{\textcolor{blue}{Information flow / Sequence of algorithm of proposed framework }}
	\label{fig:information-flow}
\end{figure}





\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{gazebo-ros-interaction}
\end{figure}






\begin{figure}
	\centering
	\begin{tikzpicture}
    % \scriptsize
    \def\gazeboblockheight{5.5cm}
    \def\rosblockheight{4cm}
    \def\gazeboblockwidth{4cm}
    \def\blockheight{0.8cm}
    \def\blockwidth{3cm}
    \def\yshiftbetweenblocks{0.5cm}
    \def\yshiftrosblocks{0.8cm}

        % Blocks
		
        % Gazebo
        \node[draw, fill=lightgray, semithick, rectangle, loosely dashed, minimum width=\gazeboblockwidth, minimum height=\gazeboblockheight, align=center, label=above:{Gazebo}] (gazebo) at (0,0) {};
        \node[draw, fill=white, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center] (thrustermodel) at (0,0.5*\gazeboblockheight-1cm) {thruster model};
        \node[draw, fill=white, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, below= of thrustermodel, yshift=\yshiftbetweenblocks] (hydrodynamics) {hydrodynamics};
        \node[minimum width=\blockwidth, minimum height=\blockheight, align=center, below= of hydrodynamics, yshift=\yshiftbetweenblocks] (rigidbody) {$+$\\rigid body\\(built in)};
        
        % ROS2
        \node[draw, fill=lightgray, semithick, rectangle, loosely dashed, minimum width=\gazeboblockwidth, minimum height=\rosblockheight, align=center, label=above:{ROS2}, right= of gazebo] (ros) {};
        \node[draw, fill=white, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center] (controlloops) at ([yshift=\yshiftrosblocks]ros.center) {control loops};
        \node[draw, fill=white, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center] (mixer) at ([yshift=-\yshiftrosblocks]ros.center) {mixer};

        \draw[-stealth] (controlloops.south) -- (mixer.north);
        \draw[-stealth] (mixer.south) -- ++(0, -2.5cm);
  
        % \draw[] ([yshift=\yshiftthreelines]gazebo.north) {$u_2$};
        % \node[align=center, above= of gazebo]  (gazebo_label) {Gazebo};
        
		% \node[draw, semithick, rectangle, minimum width=\blockwidth, minimum height=\blockheight, align=center, right= of generator, xshift=\xshiftblocks] (trackingcontroller) {Trajectory\\Tracking\\Controller};

		
        % trajectory generator - trajectory tracking controller
		%\draw[-stealth] (generator.east) -- (trackingcontroller.west) node[midway, above] {$\bm{\sigma}_{\text{des}}$};
        % trajectory tracking controller - mixer (above blocks)
        % \draw[-stealth] ([xshift=0.3cm]trackingcontroller.north) -- ++(0, \yshiftaboveblocks) -- ([xshift=\xshiftfirstuintomixer, yshift=\yshiftaboveblocks+0.5*\blockheight]mixer.west) -- ([xshift=\xshiftfirstuintomixer, yshift=2*\yshiftthreelines]mixer.west) -- ([yshift=2*\yshiftthreelines]mixer.west) node[midway, above] {$u_1$};

	\end{tikzpicture}
	\caption{\textcolor{blue}{Work in progress - Was genau wollen wir hier Ã¼berhaupt zeigen? Solver bei Gazebo noch eintragen? ZusÃ¤tzlich / Alternativ ROS node graph?}}
	\label{fig:control_architecture}
\end{figure}


\textcolor{blue}{
The control architecture presented in \Cref{sec:control} is implemented in a modular design in \ac{ros2}. While being the successor of \ac{ros}, \ac{ros2} is developed independently from \ac{ros}.
Consequently, the migration implies severe changes of the framework already existing for the HippoCampus platform. Nonetheless, this drawback is outweighed by the advantages this design decision entails. }

\ac{ros2} comes with a new generation of the simulator Gazebo, hence requiring a new implementation of the simulation setup for the HippoCampus \ac{uauv}. The dynamic behavior of a model in the simulation can be replicated via plugins. The vehicle dynamics and the thruster forces and moments are modeled based on  \Cref{eq:thruster-load-vs-uesc,eq:eom-translational-with-input,eq:eom-rotational-with-input}.


\textcolor{blue}{Based on limitations identified in \Cref{sec:sw_limitatations}....}

This can be overcome by migrating from \ac{ros} to its successor \ac{ros2}, that enables direct communication between the \ac{fcu} and the onboard computer via \ac{dds}. Hence, all software modules developed in the scope of this thesis are implemented using \ac{ros2}.

The interested reader may refer to \cite{ros2} for an exhaustive overview of the design and architecture of \ac{ros2}. The main aspects relevant for this thesis are listed below.

Embedded systems are well integrated into the \ac{ros2} framework. A \ac{ros2} stack specifically designed for microcontrollers, called micro-ROS, allows the direct communication between computers and microcontrollers. With regard to HippoCampus, this means the \ac{fcu} running PX4 and the onboard computer can communicate directly without the abstraction layers introduced by MAVROS and \ac{mavlink}. This enables high rate data streams between the devices.

Furthermore, \ac{ros2} introduces the concept of \ac{qos} as it relies on \ac{dds} for communication. Hence, data streams transporting sensor data can be declared to be transmitted with \emph{best effort}. As a result, the loss of messages is accepted, while the latency can be reduced. This especially useful for sensor data, where it is of interest to receive the most recent measurements as fast as possible. For message sizes of up to \unit[1]{MB} latencies below \unit[1]{ms} can be achieved for communication between different processes \cite{ros2}. High latencies impose delays on control loops and state estimation with possibly severe negative influence on their performance.

Though not required for this thesis, it should be noted, that \ac{ros2} is suitable for real-time systems. In contrast to its predecessor, \ac{ros2} can be configured for deterministic scheduling to enforce real-time constraints \cite{ros-realtime20}. This can be a critical property for the field of mobile robotics, where deterministic execution times can be safety critical.

